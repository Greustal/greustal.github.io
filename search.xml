<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言学习笔记（四）</title>
      <link href="/2023/07/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/07/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="括号匹配算法">括号匹配算法</h1><p><img src="/2023/07/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/191D0B1FA156A1B6C41464840D56D516.png" alt="191D0B1FA156A1B6C41464840D56D516" style="zoom:50%;"></p><h2 id="直接用数组">直接用数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize  10  <span class="comment">//定义全局变量不需要等号和分号</span></span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketMatch</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[MaxSize];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;   <span class="comment">//初始化指针为-1，指向栈顶元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>||s[i]==<span class="string">&#x27;&#123;&#x27;</span>||s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = s[i]; <span class="comment">//先+1，指向0，再赋值</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(top ==<span class="number">-1</span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stack</span>[top] == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;]&#x27;</span> || <span class="built_in">stack</span>[top] == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;&#125;&#x27;</span> || <span class="built_in">stack</span>[top] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;size);</span><br><span class="line">    <span class="type">char</span> s[size];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="type">bool</span> a = bracketMatch(s,size);</span><br><span class="line">    <span class="keyword">if</span>(a)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;matching sucessfully&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;matching failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用栈">使用栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;s)</span>&#123;</span><br><span class="line">    s.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SaStack s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;s,<span class="type">char</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==MaxSize<span class="number">-1</span>)&#123;  <span class="comment">//栈满报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.data[++s.top] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;s, <span class="type">char</span> &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == <span class="number">-1</span>)&#123;     <span class="comment">//栈空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = s.data[s.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketMatch</span><span class="params">(<span class="type">char</span> s[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    SqStack <span class="built_in">stack</span>;</span><br><span class="line">    InitStack(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>||s[i]==<span class="string">&#x27;&#123;&#x27;</span>||s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            Push(<span class="built_in">stack</span>,s[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(<span class="built_in">stack</span>))&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            Pop(<span class="built_in">stack</span>,topElem);</span><br><span class="line">            <span class="keyword">if</span>(topElem == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;]&#x27;</span> || topElem == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;&#125;&#x27;</span> || topElem == <span class="string">&#x27;(&#x27;</span> &amp;&amp; s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(<span class="built_in">stack</span>))&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（三）— 线性表</title>
      <link href="/2023/07/18/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/07/18/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="逻辑结构与存储结构">逻辑结构与存储结构</h1><h2 id="逻辑结构">1.逻辑结构</h2><ul><li>集合结构 无关系</li><li>线性结构 一对一</li><li>树形结构 一对多</li><li>图形结构 多对多（网络）</li></ul><h2 id="存储结构">2. 存储结构</h2><ul><li><p>顺序存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Array[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Array[<span class="number">3</span>]);  <span class="comment">//随机访问第四个元素：随机指访问各个元素时间复杂度相同</span></span><br></pre></td></tr></table></figure><ul><li>优点<ol type="1"><li>可以实现随机存取</li><li>每个元素占用最少的空间</li></ol></li><li>缺点<ol type="1"><li>只能使用整块的存储单元，会产生较多的碎片。</li></ol></li></ul></li><li><p>链式存储（内存中跳跃的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Lnode, *LinkList;</span><br><span class="line">L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">A -&gt; next = B;B-&gt;next = C;</span><br></pre></td></tr></table></figure><ul><li>优点<ol type="1"><li>充分利用所有存储单元，不会出现碎片（删除中间元素时直接改变前一个元素的next指针就可以）</li></ol></li><li>缺点<ol type="1"><li>需要额外的存储空间来存放下一节点的指针</li><li>只能实现顺序存取</li></ol></li></ul></li></ul><h1 id="时间复杂度与空间复杂度">时间复杂度与空间复杂度</h1><h3 id="算法的定义">算法的定义</h3><p>对特定问题求解步骤的描述</p><p>特性：有穷、确定、可行、输入、输出</p><h2 id="时间复杂度">1.时间复杂度</h2><p>时间复杂度指算法中所有语句的频度（执行次数）之和</p><p>记为：T(n) = O(f(n)) n是问题的规模；f(n)是问题规模n的某个函数</p><ul><li>O(1)表示算法复杂度不会随n的增长而增长</li></ul><p><img src="/2023/07/18/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/IMG_0430(20230718-213101).PNG" alt="IMG_0430(20230718-213101)" style="zoom: 33%;"></p><ul><li>时间复杂度计算忽略高阶项系数和低阶项</li></ul><p><img src="/2023/07/18/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/IMG_0431(20230718-213342).PNG" alt="IMG_0431(20230718-213342)" style="zoom: 33%;"></p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>  (j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">sum = sum+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//对于外层循环，相当于内部时间复杂度为O(m)的语句执行n次</span></span><br><span class="line"><span class="comment">// 时间复杂度T(n)=O(m*n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    sum = sum+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>  (j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">sum = sum+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个循环串行执行</span></span><br><span class="line"><span class="comment">// T(n) = max(O(m)+O(n))</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="空间复杂度">2.空间复杂度</h2><p>指算法运行过程中所使用的辅助空间的大小</p><ul><li>空间复杂度O(1)：指算法所需的辅助空间为常量，不随n增长而增长，即算法原地工作</li><li>额外的空间 (随着n的增长而增长的空间)</li><li>若输入数据所占空间只取决于问题本身，和算法无关，这样只需分析该算法在实现时所需的辅助单元即可</li></ul><h1 id="线性表">线性表</h1><p>定义：由n个相同类型元素的元素组成的有序集合</p><p>特点：</p><ul><li>表中元素个数有限</li><li>表中各元素数据类型相同（每个元素占用相同大小的空间）</li><li>表中元素具有逻辑上的顺序性</li></ul><p>线性表的定义是逻辑结构，还需要通过存储结构来实现</p><h2 id="线性表的顺序表示顺序表">线性表的顺序表示—顺序表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">//如果起别名这里可以省略名字</span></span><br><span class="line">    Elemtype data[MaxSize];   <span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;SqList;    <span class="comment">//类型定义</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>可以<mark class="hl-label blue">随机存取</mark> 表中任意一个元素</li><li>存储密度高，每个节点只存储数据元素（如果是链表还需要存指针）</li></ul><p>缺点：</p><ul><li><p>插入和删除不方便</p></li><li><p>存储空间容量固定，拓展容量不方便（需要将数据复制到新的区域）</p></li><li><p>占用一大段连续的存储空间，造成很多碎片</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入操作 (满足1&lt;=i&lt;=len+1)</span></span><br><span class="line"><span class="comment">//判断插入i后是否溢出 (len+1&gt;maxsize)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = len;j &gt;= i;j--) &#123;    <span class="comment">//将最后一个元素到第i个元素依次后移一位</span></span><br><span class="line">    L.data[j] = L.data[j<span class="number">-1</span>];   <span class="comment">//data[j]在线性表中指第i+1个元素</span></span><br><span class="line">&#125;</span><br><span class="line">L.data[i<span class="number">-1</span>] = x;     <span class="comment">//修改元素</span></span><br><span class="line">L.len++;         <span class="comment">//长度+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作 (满足1&lt;=i&lt;=len)</span></span><br><span class="line">e = L.data[i<span class="number">-1</span>]    <span class="comment">//保存被删除的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = len;j&lt;L.len;j++)&#123;</span><br><span class="line">    L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">&#125;</span><br><span class="line">L.len--</span><br></pre></td></tr></table></figure><p>动态分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elemtype *data;    <span class="comment">//使用时需要用malloc申请指针，否则无效</span></span><br><span class="line">    <span class="type">int</span> MaxSize,len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始动态内存分配</span></span><br><span class="line">L.data = (*Elemtype)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Elemtype)*InitSize);</span><br></pre></td></tr></table></figure><p>插入算法实战：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  <span class="comment">//让顺序表在存储其它类型元素时能迅速完成修改。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType ele)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.len==MaxSize)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;i&lt;=L.len+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=L.len;j&gt;=i;j--)&#123;</span><br><span class="line">            L.data[j] = L.data[j<span class="number">-1</span>];   <span class="comment">//前一个数赋值给后一个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        L.data[i<span class="number">-1</span>] = ele;   <span class="comment">//第i个数索引是i-1</span></span><br><span class="line">        L.len++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">del_ele</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;  <span class="comment">//L和e都需要引用</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; i&lt;L.len)&#123;</span><br><span class="line">        e = L.data[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.len;j++)&#123;</span><br><span class="line">            L.data[j<span class="number">-1</span>] = L.data[j];    <span class="comment">//第i后元素后的元素都前移</span></span><br><span class="line">        &#125;</span><br><span class="line">        L.len--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">searchid</span><span class="params">(SqList L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e == L.data[i])&#123;    <span class="comment">//如果e是结构体，那么不能直接用==判断相等，需要遍历每一个成员</span></span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;  <span class="comment">//因为i是数组的下标，加一是顺序表的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>,L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="type">bool</span> ret;  <span class="comment">//用来装函数的返回值</span></span><br><span class="line">    L.data[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    L.data[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">    L.data[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    L.len = <span class="number">3</span>; <span class="comment">//一定要定义数组长度</span></span><br><span class="line">    ret = ListInsert(L, <span class="number">2</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)&#123;</span><br><span class="line">        print(L);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cannot convert '<brace-enclosed initializer list>' to 'int' inassignment</brace-enclosed></p><p>// 因为在ListInsert()里，已经对datas这个数组初始化了， //那么datas这个数组名作为一个指针，已经指向了内存中的一个位置，so不能再次对它初始化// 所以只能用循环语句给它赋值，让他指向新的内存单元。</p><h2 id="线性表的链式存储链表">线性表的链式存储—链表</h2><p>逻辑上相邻，物理上不一定相邻</p><h2 id="单链表">单链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> &#123;</span><span class="comment">//单链表节点类型，由于结构体内定义相同类型指针，因此名称不能省略</span></span><br><span class="line">    ElemType data;     <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;Lnode, *LinkList;<span class="comment">//Lnode* 强调这是一个结点，Linklist强调是一个单链表</span></span><br><span class="line"><span class="comment">//L = (LinkList)malloc(sizeof(Lnode));</span></span><br><span class="line"><span class="comment">//A -&gt; next = B;B-&gt;next = C;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始一个空的单链表，带头结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123; <span class="comment">//这里L是一个指向头结点的指针，也不是一个结点，也没有data值</span></span><br><span class="line">    L = (Lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));  <span class="comment">//注意是给L指向的区域分配空间，L-&gt;next是L指向的区域的指针指向的区域（套娃）</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//内存不足，分配失败</span></span><br><span class="line">    &#125; </span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//头结点之后没有结点，这也是判断单链表是否为空的条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;   <span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line">    InitList(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建新节点</span></span><br><span class="line">q = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">q-&gt;next = x;<span class="comment">//表头插入</span></span><br><span class="line"></span><br><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = q;<span class="comment">//中间插入q元素</span></span><br><span class="line"></span><br><span class="line">p-&gt;next = q;</span><br><span class="line">q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表头删除元素</span></span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;<span class="comment">//链式表的断链</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"></span><br><span class="line"><span class="comment">//按序号查找</span></span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line"><span class="type">int</span> j =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;j&lt;i) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data != e)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure><ul><li>头指针：链表中第一个结点的存储位置，用来标识单链表</li><li>头结点：在单链表第一个结点之前附加的一个结点，为了操作方便（一般数据为空，或存放链表长度）</li></ul><p>优点：</p><ul><li>不需要移动元素（只修改指针就可以）</li><li>不需要大量的存储空间</li></ul><p>缺点：</p><ul><li>指针域浪费空间</li><li>查找时需要从表头开始查找，不能随机存取（顺序表可以直接按地址查找）</li></ul><h3 id="自己写的链表报错总结">自己写的链表报错总结</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">print_link</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="comment">//   这里本来想写一个检测是否初始化的函数，但是目前我还没找到方法，没初始化就是用不了</span></span><br><span class="line"><span class="comment">//    if(L-&gt;next != NULL)&#123;      //如果L没有初始化，程序报错，不能进行任何操作</span></span><br><span class="line"><span class="comment">//        printf(&quot;linklist is not initialized&quot;);</span></span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;linklist is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(L-&gt;next)&#123;     </span><br><span class="line">            <span class="comment">//第一个L-data就是头结点里的数据，没有意义，不打印</span></span><br><span class="line">  </span><br><span class="line">            L = L-&gt;next;    <span class="comment">//当L-&gt;next 不为null时，我们直接跳到L-&gt;next所在位置，获取他的data；</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L -&gt;data); </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在第i个位置插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_insert</span><span class="params">(LinkList &amp;L,ElemType e,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Lnode* p = L;   <span class="comment">//如果不带头结点，i=1的情况需要专门处理</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;   <span class="comment">//j代表当前p 指向第几个元素</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;   <span class="comment">//p指向第i-1个元素时退出</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;   <span class="comment">//这里开始可以封装为一个函数InsertNextNode(LNode *p,ElemType e),在指定节点后插入元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Lnode* s = (Lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)&#123;  <span class="comment">//内存申请失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Listdel</span><span class="params">(LinkList &amp;L,ElemType &amp;e,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Lnode* p = L;   <span class="comment">//如果不带头结点，i=1的情况需要专门处理</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;   <span class="comment">//j代表当前p 指向第几个元素</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;   <span class="comment">//p指向第i-1个元素时退出</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||p-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Lnode* s = p-&gt;next;</span><br><span class="line">    e = s-&gt;data;</span><br><span class="line">    </span><br><span class="line">    p-&gt;next = s-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(s);   <span class="comment">//一定要免费一定要免费一定要免费</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L;   <span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    Lnode* l = L;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">6</span>,<span class="number">43</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">54</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="comment">//这里如果前面定义 Lnode*l = L-&gt;next;   </span></span><br><span class="line">      <span class="comment">//这里改成 给l申请内存 就会报错,我以为道理是一样的</span></span><br><span class="line">      <span class="comment">//但是其实L-&gt;next他是没有申请内存的，根本就用不了，所以这里一定是复制一个L，L-&gt;next 是复制不了的</span></span><br><span class="line">        l-&gt;next = (Lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));   </span><br><span class="line">       </span><br><span class="line">        l =l -&gt;next;    <span class="comment">//这两句不能颠倒，否则l-&gt;data就是往头结点中写数据，l-&gt;next-&gt;data才是第一个节点</span></span><br><span class="line">        l -&gt;data = a[i];</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">            l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_link(L);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在指定节点前插入元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertpriorNode</span><span class="params">(Lnode* p, ElemEype e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Lnode* s = (Lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;      </span><br><span class="line">    s-&gt;data = p-&gt;data;  <span class="comment">//把p的数据和s互换，把后插转化为前插</span></span><br><span class="line">    p-&gt;data = e;     <span class="comment">//偷天换日</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除制定节点p</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    LNode* s = p-&gt;next;   <span class="comment">//将p的后继节点s数据复制到p中，断掉节点s</span></span><br><span class="line">    p-&gt;data = s-&gt;data;</span><br><span class="line">    p-&gt;next = s-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//如果p是最后一个节点会出问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按位查找">按位查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回第i个元素</span></span><br><span class="line">LNode* <span class="title function_">GetElem</span><span class="params">(Linklist L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    Lnode* p = L;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;  <span class="comment">//如果i超值，那么返回的值也为NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line">LNode* <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">    LNode*p = L-&gt;next;</span><br><span class="line">    <span class="comment">//从第一个节点开始寻找数据域为e的元素</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p!=e)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//找到后返回改节点类型，否则返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求链表长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    LNode* p = L;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以替换之前的插入、删除函数的查找部分</p><ul><li>避免重复代码，简洁、易维护</li></ul><h3 id="单链表的建立">单链表的建立</h3><ul><li>尾插法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TaiInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">Lnode* x = L;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ele;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ele);</span><br><span class="line">    <span class="keyword">while</span>(ele !=<span class="number">494</span>)&#123;</span><br><span class="line">        x-&gt;next = (Lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">        x-&gt;next -&gt;data = ele;</span><br><span class="line">        x = x-&gt;next;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ele);</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头插法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">Lnode* x = L;</span><br><span class="line">    L-&gt;next =<span class="literal">NULL</span>;  <span class="comment">//只要是初始化链表时，尽量都先把头指针指向NULL</span></span><br><span class="line">Lnode* n;</span><br><span class="line">    <span class="type">int</span> ele;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ele);</span><br><span class="line">    <span class="keyword">while</span>(ele !=<span class="number">494</span>)&#123;</span><br><span class="line">        n = (Lnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">        n-&gt;next = L-&gt;next;  <span class="comment">//在指定节点（头结点）后插入新节点</span></span><br><span class="line">        n-&gt;data = ele;</span><br><span class="line">        L-&gt;next = n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;<span class="comment">//重要应用:链表的逆置</span></span><br><span class="line"><span class="comment">//建立新链表或者循环原地逆置</span></span><br></pre></td></tr></table></figure><ul><li>原地逆置的练习</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_invert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    Lnode* p = L-&gt;next; <span class="comment">//第一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    Lnode* s = p-&gt;next; <span class="comment">//第二个元素</span></span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next =<span class="literal">NULL</span>;  <span class="comment">//由于第一个元素逆置后会成为最后一个元素，所以先NULL为敬</span></span><br><span class="line">    <span class="keyword">while</span> (s!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        Lnode* h = s;</span><br><span class="line">        h = s-&gt;next;</span><br><span class="line">        s-&gt;next = L-&gt;next;   <span class="comment">//转移到头部</span></span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">        s = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表">双链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>  <span class="comment">//一个节点定义</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span>&#123;  <span class="comment">//初始化双链表</span></span><br><span class="line">    L = (DLinkList)<span class="built_in">malloc</span>(typeof(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//内存申请失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(DLinkList L)</span>&#123;  <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">(DNode *p, DNode *s)</span>&#123; <span class="comment">//制定节点后插s</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = s;  <span class="comment">//如果是循环链表就没问题，如果不循环，需要判断p-&gt;next是否为NULL</span></span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete</span><span class="params">(*p)</span>&#123;  <span class="comment">//删除p节点的后继节点</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;next-&gt;prior = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表">循环链表</h3><p>循环单链表</p><ul><li>初始化：最后节点的next指针指向自己（等于L）</li><li>从一个节点出发可以找到其它任意节点</li><li>如果经常对表头或表尾进行操作时，可以将L指向表尾（插入表尾元素时需要修改L）</li><li>判空 L-&gt;next ==L 判断是否为尾结点p -&gt;next ==L</li></ul><p>循环双链表</p><ul><li>插入或删除后节点时不用考虑next为空指针的情况</li></ul><div class="note primary modern"><p><strong>注意：</strong></p><ol type="1"><li><p>如何判空</p></li><li><p>如何判断节点是否是表尾、表头节点</p></li><li><p>如何在表头、表中、表尾插入/删除一个节点</p></li></ol></div><h3 id="静态链表">静态链表</h3><p>用数组方式实现的链表</p><ul><li>单链表：各个节点在内存中随机分配</li><li>静态链表：分配一整片的内存空间</li></ul><p>特点：</p><ul><li><p>0号节点充当头节点</p></li><li><p>游标（充当指针）：指向下一个节点的数组下标</p></li><li><p>-1表示达到表尾</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize]; <span class="comment">//声明一个大小为maxsize的结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span></span><br></pre></td></tr></table></figure><ul><li>初始化：a[0] = -1、标记空闲节点（设置为-2）</li><li>查找：从头结点开始挨个遍历</li><li>插入位序为i的节点：<ul><li>找到一个空的节点，存入数据元素</li><li>从头结点开始找到 i-1的元素</li><li>修改新节点next 》 修改i-1的节点next 指向新节点</li></ul></li></ul><p>容量固定不可变，应用场景较少，主要用于</p><ol type="1"><li><p>不支持指针的低级语言</p></li><li><p>数据元素数量固定不变的场景（操作系统的文件分配表FAT）</p></li></ol><h2 id="总结">总结</h2><p>销毁操作：</p><ul><li>由数组申请的空间，系统会自动回收，只需设置length=0即可</li><li>由malloc申请的空间，需要对每一个节点free</li></ul><p>使用场景：</p><ul><li><p>表长难以预估、经常增删元素 ——使用链表</p></li><li><p>表长固定，经常查找元素 ——使用顺序表</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（二）— 指针、函数、结构体</title>
      <link href="/2023/07/18/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2023/07/18/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="指针">指针</h1><h2 id="指针的定义">1.指针的定义</h2><ul><li>直接访问：按变量地址存取变量值的方式。</li><li>间接访问：将变量i的地址存储到另一个变量（指针变量）。</li></ul><p>变量的地址指的就是变量的起始地址</p><ul><li><p>定义：<code>int *i_pointer</code></p></li><li><p>指针和指针变量：</p><ul><li>指针等价于地址</li><li>指针变量：存放指针的变量</li></ul></li><li><p>所占空间：如果程序为64位，占8字节；32位为4个字节。</p></li><li><p>取地址运算符&amp;，取值操作符*（得到一个变量对应的地址数据）（单目运算符，右到左）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> *i_pointer = &amp;i; <span class="comment">//指针数据类型和原变量类型相同</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *i_pointer); <span class="comment">//间接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="指针的使用场景传递和偏移">2.指针的使用场景：传递和偏移</h2><h3 id="指针的传递">指针的传递</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    j = <span class="number">5</span>;<span class="comment">//使用指针间接访问  *j=5;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    change(i);</span><br><span class="line">    print(<span class="string">&quot;%d\n&quot;</span>,i); <span class="comment">//i的值不会改变，c语言的函数调用是实参赋值给形参</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change2</span><span class="params">(<span class="type">int</span> *j)</span>&#123;</span><br><span class="line">    *j = <span class="number">5</span>; <span class="comment">//*j等价于i，只是间接访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i= <span class="number">10</span>;</span><br><span class="line">    change2(&amp;i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程地址空间：</p><p><img src="/2023/07/18/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/7522EF52D55962833EEBC5447AC319D0.png" alt="7522EF52D55962833EEBC5447AC319D0" style="zoom: 33%;"></p><h3 id="指针的偏移">指针的偏移</h3><ul><li><p>偏移：指针的加减</p></li><li><p>指针p+1，增加大小依赖于基类型的字节长度</p><p>如int *p,p的加减偏移4个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span> *d)</span>  <span class="comment">//不存在传递数组的说法，只能传递指针的值</span></span><br><span class="line">&#123;</span><br><span class="line">    *d = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>; <span class="comment">//两种方式等价</span></span><br><span class="line">    *d + <span class="number">2</span>= <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="指针与malloc动态内存申请">3. 指针与malloc动态内存申请</h2><h3 id="指针与动态内存申请">指针与动态内存申请</h3><ul><li><p>栈空间：在编译时大小确定，数组中定义的整型、浮点型、字符型变量都在栈空间中，因此长度确定</p><p>堆空间：空间大小不确定</p></li><li><p>如何申请堆空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//malloc使用的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">//size代表申请的空间大小</span></span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);<span class="comment">//输入申请空间大小</span></span><br><span class="line">    p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size); <span class="comment">//malloc返回void*无类型指针，需要强制类型转换，</span></span><br><span class="line">        <span class="comment">//void*指针不能偏移，否则进行指针加减会报错</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;malloc success&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放申请的空间，栈空间由操作系统管理，不需要释放</span></span><br><span class="line">    <span class="comment">//p必须是最初malloc返回的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2023/07/18/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/D467F3041D7BDB98905BB286057BEFBD.png" alt="D467F3041D7BDB98905BB286057BEFBD" style="zoom:33%;"></p><ul><li><p>为什么分栈空间和堆空间？</p><ul><li><p>栈（heap）：计算机系统提供的数据结构；分配专门的寄存器存放栈的地址，有专门的压栈、出栈操作指令</p></li><li><p>堆（stack）：函数库提供的数据结构；由算法实现。</p></li><li><p>堆的效率比栈低得多</p></li><li><p>栈空间中的数据在函数执行结束后会被释放，堆空间在整个进程中一直有效，不因函数结束而消亡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">print_stack</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">100</span>] = <span class="string">&quot;I am print_stack func&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">print_malloc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;I am print_malloc func&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = print_stack();</span><br><span class="line">    <span class="built_in">puts</span>(p);  <span class="comment">//此时输出值错误或为空值</span></span><br><span class="line">    p = print_malloc();</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="函数">函数</h1><h2 id="函数声明与定义">1. 函数声明与定义</h2><ul><li><p>使用多个文件：右键项目名称—新建C/C++源文件—添加到目标（和<code>main.c</code>编译到一个可执行文件中）—创建<code>func.c</code></p><p>新建C/C++头文件<code>func.h</code>（执行时直接拷贝到各个.c文件中）</p></li></ul><p>​ <code>func.h</code>中写函数的声明，<code>func.c</code>写函数实现</p><ul><li><strong>Ctrl+鼠标左键</strong> 点击对应函数，可以查看对应源码、</li><li>由若干程序源文件组成一个c程序，这样处理便于<strong>分别编写、分别编译，进而提高调试效率</strong></li><li>函数不能嵌套定义，但是可以嵌套调用</li><li>函数可以互相调用，但不能调用main</li><li>函数的声明需要：函数的名字、函数类型及形参的类型、个数和顺序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_message</span><span class="params">()</span>;<span class="comment">//如果函数定义在main后面，需要先进行声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> i,<span class="type">char</span> c)</span>;<span class="comment">//如果不声明函数默认返回整型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    print_message();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_message</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;how are you &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的递归调用">2. 函数的递归调用</h2><ul><li><p>我们把函数自己调用自己叫做递归，递归函数一定要有结束条件，否则会产生死循环。</p></li><li><p>递归的核心是找公式</p><p>f(n) = n*f(n-1) 找出f(n)和f(n-1)的关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;<span class="comment">//一定要有结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>==n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n*f(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>例题：假如有n个台阶，一次智能上1个台阶或2个台阶，请问走到第n个台阶有几种走法？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step(n) = step(n-1) + step(n-2)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">step</span><span class="params">(<span class="type">int</span> n)</span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>==n||<span class="number">2</span>==n)&#123; <span class="comment">//当台阶是1个或者2个时，递归结束</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step(n<span class="number">-1</span>) + step(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;   </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,n);   <span class="comment">//输入数字太大，递归次数过多会导致栈溢出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,step(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量与全局变量">3.局部变量与全局变量</h2><p>全局变量：</p><ul><li>全程都会占用内存空间，不建议使用</li><li>使用过多降低程序清晰性。</li><li>将函数移动到另一个文件时容易产生问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>; <span class="comment">//i是一个全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> a)</span>&#123;  <span class="comment">//形参可以看成局部变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">5</span>;    <span class="comment">//局部变量只在离自己最近的大括号内有效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main i = %d\n&quot;</span>,i);</span><br><span class="line">    i = <span class="number">5</span>; <span class="comment">//此时正常修改全局变量</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">6</span>;<span class="comment">//局部变量和全局变量重名，采取就近原则，即实际获取或修改都是局部变量的值</span></span><br><span class="line">    print(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于形参和实参">关于形参和实参：</h3><ul><li>形参在没有调用时不会占用内存空间</li><li>实参可以使变量、常量、表达式，但要有确定的值</li><li>实参与形参个数要相等，类型相同</li><li>函数调用结束后形参单元被释放</li></ul><h1 id="结构体">3.结构体</h1><h2 id="结构体的定义初始化结构体数组">1.结构体的定义、初始化、结构体数组</h2><blockquote><p>C语言提供结构体管理不同类型的数据组合</p></blockquote><h3 id="结构体声明">结构体声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> //结构体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="type">char</span> addr[<span class="number">30</span>];<span class="comment">//成员表列</span></span><br><span class="line">&#125;;<span class="comment">//最后要加分号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s</span> =</span> &#123;<span class="number">10001</span>,<span class="string">&quot;lele&quot;</span>,<span class="string">&#x27;M&#x27;</span>, <span class="number">20</span>, <span class="number">85.4</span>,<span class="string">&quot;Shenzhen&quot;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">sarr</span>[3];</span><span class="comment">//结构体数组,通过for循环访问</span></span><br><span class="line">    <span class="comment">//结构体输出必须单独去访问内部的每个成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %c %d %f %s&quot;</span>,s.num,s.name,s.sex,s.age,s.score,s.addr);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d%s %c%d%f%s&quot;</span>,&amp;s.num,&amp;s.name,&amp;s.sex,&amp;s.age,&amp;s.score,&amp;s.addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %c %d %f %s&quot;</span>,s.num,s.name,s.sex,s.age,s.score,s.addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个成员单独复制 <code>s.num = 1004</code></p><h3 id="结构体对齐">结构体对齐</h3><ul><li><p><strong>结构体大小必须是其最大成员的整数倍</strong> -&gt;为了cpu能高效地取内存上的数据</p></li><li><p>结构体内的成员也要按最大成员的字节数对齐</p></li><li><p>大小和结构体位置有关系，例如如果short和char挨着，如果最大4字节，就会合并占用4个字节，减少使用空间</p></li></ul><p>例题：问结构体类型大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_type1</span> &#123;</span></span><br><span class="line"><span class="type">double</span> score;</span><br><span class="line"><span class="type">short</span> age;  <span class="comment">//整型，占2个字节，其它和int相同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_type2</span> &#123;</span></span><br><span class="line"><span class="type">double</span> score;</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="type">short</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_type3</span> &#123;</span></span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line">    <span class="type">char</span> sex;  <span class="comment">//如果两个小之和小于最大存储8，那么他们结合在一起</span></span><br><span class="line"><span class="type">short</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student_type1</span> <span class="title">s1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student_type2</span> <span class="title">s2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student_type3</span> <span class="title">s3</span>;</span></span><br><span class="line">    print(<span class="string">&quot;size = %d\n&quot;</span>,<span class="keyword">sizeof</span>(s1)); <span class="comment">// 16 个字节</span></span><br><span class="line">    print(<span class="string">&quot;size = %d\n&quot;</span>,<span class="keyword">sizeof</span>(s2)); <span class="comment">// 16 个字节</span></span><br><span class="line">    print(<span class="string">&quot;size = %d\n&quot;</span>,<span class="keyword">sizeof</span>(s3)); <span class="comment">// 8 个字节  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体指针与typedef的使用">2. 结构体指针与typedef的使用</h2><h3 id="结构体指针">结构体指针</h3><p>结构体变量的地址就是该变量所占据的内存段的起始地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结构体指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;hutao&quot;</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">sarr</span>[3] =</span> &#123;<span class="number">1002</span>, <span class="string">&quot;zhongli&quot;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="number">1003</span>,<span class="string">&quot;wanye&quot;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="number">1004</span>,<span class="string">&quot;keqing&quot;</span>,<span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span> <span class="comment">//定义一个指针变量</span></span><br><span class="line">    p = &amp;s;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %c\n&quot;</span>,(*p).num,(*p).name,(*p).sex); <span class="comment">//方式一获取成员，.的优先级大于*，因此需要加括号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %c\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;sex); <span class="comment">//方式二快速访问结构体指针的成员</span></span><br><span class="line">    p = sarr; <span class="comment">//等价于 p = &amp;sarr[0];都是指向数组第一个元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %c\n&quot;</span>,(*p).num,(*p).name,(*p).sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %c\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;sex);</span><br><span class="line">    p = p+<span class="number">1</span>; <span class="comment">//指向下一个结构体变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typedef的使用">typedef的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef的使用，起别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;stu,*pstu;     <span class="comment">//stu 等价于 struct student, pstu 等价于 struct student*</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    stu s=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    stu *p=&amp;s;</span><br><span class="line">    pstu p1=&amp;s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER; <span class="comment">//便于在特定的地方改变数据类型 如：改为short类型</span></span><br></pre></td></tr></table></figure><h1 id="拓展c引用">拓展：C++引用</h1><p>c++文件后缀，main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifynum</span><span class="params">(<span class="type">int</span> &amp;b)</span> <span class="comment">//这里的&amp;不是取地址，而是引用，引用后可以直接修改函数外的变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b = b+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modify_num</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after modify_num a=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用了引用后，在子函数内和函数外操作手法一致，提高编程效率</li><li>想在子函数中改变主函数变量的值就用引用，不改变就使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_pointer</span><span class="params">(<span class="type">int</span> * &amp;p,<span class="type">int</span> *q)</span>   <span class="comment">//如果改为c语言，则需要用到二级指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子函数内修改主函数的一级指针变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *q = &amp;i;</span><br><span class="line">    <span class="built_in">modify_pointer</span>(p,q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>,*p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：在主函数定义字符指针char*p,然后在子函数内malloc申请空间（大小为100个字节）,通过fgets读取字符串，然后在主函数中进行输出；要求子函数使用C++的引用，注意在C++中从标准输入读取字符串，需要使用fgets(p,100,stdin)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//malloc使用的头文件</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">malloc_apply</span><span class="params">(<span class="type">char</span> *&amp;p)</span></span>&#123;</span><br><span class="line">    p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">fgets</span>(p,<span class="number">100</span>,stdin); <span class="comment">//比gets更安全，不会出现stdin超出100个字符的情况</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">malloc_apply</span>(p));</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记(一)</title>
      <link href="/2023/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <url>/2023/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="c语言">C语言</h1><h2 id="由来">由来</h2><p>ALGOL（A语言）→ BCPL（B语言）</p><p>世界上第一个c语言编辑器使用B语言写的</p><p>C语言之父：ken thompson Dennis M.Ritchie</p><h2 id="clion开发-环境">clion开发 环境</h2><p>注意：1.项目存储路径必须全英文</p><p>c++项目 c++ exectuable</p><p>c 项目 c exectuable</p><ul><li><p>环境激活试用</p><p>将激活文件夹拖入窗体中</p><p><a href="https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E5%92%8C%E6%95%99%E5%B8%88%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F">学生和教师授权申请方式– 许可和购买常见问题解答 (jetbrains.com)</a></p><p>激活教育版</p><ul><li><p>远程协助软件</p><p>国外 teamview</p><p>国内 向日葵</p></li></ul></li><li><p>编译与调试</p><ul><li><p>代码文件</p><p>不同语言以后缀名来区分如.c, .java, .py，但本质上都是文本文件</p></li><li><p>编译</p><p>将人工编写的代码转换机器可以执行的程序（纯二进制码）</p></li><li><p>调试</p><p>左侧红点：打断点</p><p>点击虫子（调试按钮）</p><p>出现蓝色长条，开始调试，从当前这行开始运行（当前行未运行）</p><p>点击折弯箭头运行一步</p><ul><li>步过：当前函数一步一步走 F8</li><li>步入：进入到某个子函数F7（到达某个函数要进入自己的子函数时使用）</li></ul></li></ul></li><li><p>代码格式</p><p>头文件</p><p>#include studio.h</p><p><a href="https://blog.csdn.net/weixin_43491077/article/details/109012061">(16条消息)C语言中头文件中#include“stdlib.h“的作用_#include&lt;stdlib.h&gt;_阿槐123456的博客-CSDN博客</a></p><p>int(函数返回值类型)</p><p>main()主函数名，每个c语言程序只能有一个main，程序从main开始执行</p></li></ul><h3 id="数据类型-常量-变量">数据类型-常量-变量</h3><ul><li><p>数据类型</p><ul><li>基本类型<ul><li>整形 int</li><li>浮点型 float</li><li>字符型 char</li></ul></li><li>构造类型<ul><li>数组（相同数据类型）</li><li>结构体（不同数据类型）</li></ul></li><li>指针类型 *</li><li>空类型 void</li></ul></li><li><p>常量</p><p>整形、实型（浮点型）、字符型‘a’ <em>(单引号)</em>、字符串型“abc”<em>(双引号)</em></p></li><li><p>变量（整型-浮点-字符）</p><p><strong>在程序执行过程中可以改变</strong></p><ul><li><p>命名：字母、下划线、数字（不能数字开头）</p><p>不能与关键字重名</p><figure><img src="/2023/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/Untitled.png" alt="c语言中的关键字"><figcaption aria-hidden="true">c语言中的关键字</figcaption></figure></li><li><p>先定义，后使用</p></li></ul></li><li><p>符号常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;studio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3+2   <span class="comment">//定义符号变量</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = PI*<span class="number">2</span>;  <span class="comment">//直接替换结果，不能赋值</span></span><br><span class="line">    print(<span class="string">&quot;%d\n&quot;</span>,i); <span class="comment">//结果为7，PI*2 = 3 + 2*2 = 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>整型变量</p><ul><li>每个整数四个字节（4Byte）</li><li>查看变量大小： sizeof(i)</li><li>输出%d</li></ul></li><li><p>浮点型常量</p><p><a href="https://www.zhihu.com/question/55152080">(24 封私信 / 80条消息) c语言：为什么把整数以%f格式输出是0.000？ - 知乎(zhihu.com)</a></p><p>float f = 3e-3 0.003（四个字节）</p><p>小数形式</p><p>指数形式 3e-3</p><figure><img src="/2023/07/17/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/Untitled%201.png" alt="Untitled"><figcaption aria-hidden="true">Untitled</figcaption></figure></li><li><p>字符</p><ul><li><a href="https://www.asciim.cn/">ASCII码 -基本ASCII码和扩展ASCII码,最全的ASCII码对照表(asciim.cn)</a>(每个字符占一个字节)</li></ul></li><li><p>字符串常量</p><p>结尾处有’\0’作为结束标志，占n+1个字节</p></li><li><p>混合运算</p><p>强制类型转换</p><p>(float)i</p><p>进行除法时需要转换类型<code>int i = 5; float k = float(i/2)</code>,否则默认整除</p></li><li><p>内存视图（集成开发环境看内存都用十六进制展示）（每个位置显示一个字节byte）</p><p>英特尔cpu采用小端方式进行数据存储，因此低位在前，高位在后（低位字节在前）</p><p><a href="https://blog.csdn.net/shuxiachai/article/details/127322794">(16条消息)王道C语言督学营OJ题解合集（24考研人持续更新ing）_王道c语言督学营资源-CSDN博客</a></p></li></ul><h3 id="函数">函数</h3><ul><li><p>printf</p><ul><li>原理：将不同类型的数据格式转化为字符串，放入标准输入缓冲区，然后将结果显示到屏幕上</li></ul><p>%c 以字符形式输出 %d 以整型输出</p><p>%3d 占三个空格的位置</p><p>浮点数%5.2 占五个空格 保留两位小数</p><p>默认右对齐，数字前加- 代表左对齐</p><p><a href="https://blog.csdn.net/qq_29874741/article/details/94626531">(16条消息)c语言printf()输出格式大全_printf输出格式_rusty_knife的博客-CSDN博客</a></p></li><li><p>scanf 读取数据</p><p>读取标准输入（键盘输入）</p><p><a href="https://zhuanlan.zhihu.com/p/436420553">scanf（"%d",&amp;a）回车无法结束输入问题- 知乎 (zhihu.com)</a></p><p>后面不能加</p><ul><li>输入回车后，</li></ul><p>标准输入缓冲区（最多输入4096字节）: 实际输入10，但scanf只读走了10</p><blockquote><p>如果剩余， scanf(”%c”,&amp;c)会把“”读走</p><p>解决：fflush（stdin）;清空标准输入缓冲区</p></blockquote><ul><li>scanf在读取整数%d、浮点数%f、字符串%s时会忽略‘’换行符、回车符等字符，读取字符%c时不会忽略，%c不会忽略任何字符，包括空格（32）</li><li>读取多个字符<code>scanf("%d %s%f",&amp;i,&amp;c,&amp;f)</code>，输入时在i和c之间加一个空格，</li><li>ret= scanf()代表匹配成功的个数（读取多个值时）问题解决：在%c前加一个空格</li><li>读取字符数组时，不需要取地址（字符数组中存储了地址信息），自动往字符数组中放结束符</li></ul></li><li><p>gets 读取一行（到）</p><p>遇到，不会存储，而是转化为结束符\0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">20</span>];</span><br><span class="line">    gets(c);<span class="comment">//gets中放入字符数组数组名即可</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>puts</p><p>puts(c) 等价于 printf(”%s”,c)，参数只能为字符数组名</p></li><li><p>str系列</p><p>引用<strong>#including &lt;string.h&gt;</strong></p><ul><li><p>strlen 获取字符串长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">len = <span class="built_in">strlen</span>(c);</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrlen</span><span class="params">(<span class="type">char</span> c[])</span>&#123;  <span class="comment">//自定义实现strlen函数</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c[i])&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>strcopy(c,d)将一个数组的字符串复制到前面的数组中(d中复制给c)</p></li><li><p>strcat(c,d) 拼接两个字符数组</p></li><li><p>strcmp(e, c) 比较两个数组</p><p>相等，返回0不相等，比较大小（按asc码值比较）前大于后返回正值，前小于后返回负值</p><p>strcat和strcopy第一个参数要放数组名</p></li></ul></li></ul><h4 id="定义函数">定义函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> length)</span>&#123;    <span class="comment">//void 代表函数输出类型为空，此时可以不写return，如果是int代表输出为整数（return 0）</span></span><br><span class="line">       <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">for</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">       print(a, <span class="number">5</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="运算符">运算符</h3><ul><li><p>短路运算</p><p>i&amp;&amp;表达式当i为假时，不会执行逻辑与后的表达式，称为短路运算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">i&amp;&amp;<span class="title function_">printf</span><span class="params">(<span class="string">&quot;此时输出不了&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>i || 表达式 当i为真时，不会执行逻辑与后的表达式</p></li><li><p>赋值运算符 =</p><p>a+25 = b</p><p>左值报错：左侧没有变量lvalue required as left operand ofassignment</p></li><li><p>求字节运算符</p><p>sizeof 是一个运算符，不是函数(求常量或变量所占空间大小）</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/30007037#:~:text=%E8%BF%98%E6%98%AF%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%B8%A6%E5%87%BA%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E7%9C%8B%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8C%E7%90%86%E8%AE%BA%E4%B8%8A%EF%BC%8C32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%B8%8B%EF%BC%8Cint%E5%8D%A04byte%EF%BC%8Cchar%E5%8D%A0%E4%B8%80%E4%B8%AAbyte%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%86%E5%AE%83%E4%BB%AC%E6%94%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E5%BA%94%E8%AF%A5%E5%8D%A04%2B1%3D5byte%EF%BC%9B%E4%BD%86%E6%98%AF%E5%AE%9E%E9%99%85%E4%B8%8A%EF%BC%8C%E9%80%9A%E8%BF%87%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF8,byte%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%89%80%E5%AF%BC%E8%87%B4%E7%9A%84%E3%80%82">C/C++内存对齐详解- 知乎 (zhihu.com)</a></p><ul><li><p>c语言中单引号‘’只能用来表示单个字符，如果出现多个字符，则编译出错</p></li><li><p>优先级：逻辑非&gt;算数运算符＞逻辑与＞逻辑或</p><p><a href="https://blog.csdn.net/changexhao/article/details/82556761">(16条消息)C语言运算符优先级列表(超详细)_c语言运算符优先级由高到低的顺序_Vance2016的博客-CSDN博客</a></p></li></ul><h3 id="数组">数组</h3><ul><li>定义格式： 类型说明符 数组名 [常量表达式]；</li><li>数组内元素类型必须相同</li><li>不能用变量说明数组大小</li><li>可以初始化一部分值，其它为0</li><li>可以不用写元素个数，编译器会自动计算数组大小（不推荐）a[]={1,2,3}</li></ul><p>例：int a[5]</p><ul><li><p>内存的存储</p><p>每个数据元素占用的字节数，就算基础类型的字节数，一个元素占4字节(int类型)</p></li><li><p>越界访问 access of bounds</p><p>越界访问会造成数据异常，操作系统对内存中每一个位置都给予编号，</p><p>Windows 32位控制台应用程序：0x00 00 00 00 到0xFF FF FFFF，总计为2的32次方，大小为4G，这些编号称为地址</p><p>危险之处：会改变其它变量的值（编译器不会检查）</p></li><li><p>数组的传递</p><ul><li><p>数组名传递到子函数后，子函数形参接收到是数组的起始地址，因此不能通过sizeof获得数组长度传递给子函数（弱化为了指针—大小为8字节）（只能自己定义一个变量传递数组长度）</p></li><li><p>传递时后面不用写数字，没有意义，不会传递过去</p></li></ul></li><li><p>字符数组</p><ul><li>初始化</li></ul><p>char c[10]={’I’,’b’,’c’,……}</p><p>char c[10] = “Iamhappy”使用这种方式初始化（实际为9个字符，最后一个用来存储‘\0’）</p><p>char c[6] = “happy”</p><p>printf(”%s”,c)直接输出字符串（如果是c[5]，没有结束符，则后面会输出乱码）</p><p>结束符\0的值为零（可以作为判断条件）</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>补码乘法的证明</title>
      <link href="/2023/07/15/%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95%E7%9A%84%E8%AF%81%E6%98%8E/"/>
      <url>/2023/07/15/%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95%E7%9A%84%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="补码乘法的证明">补码乘法的证明</h1><p>在刚开始学计算机组成的时候，因为不明白补码乘法规则的原理，网上找了很多说明的文章才搞明白，所以这里总结一下。<span id="more"></span></p><h2 id="booth算法">Booth算法</h2><p>首先要了解一下模的概念，“模”实质上是计量器产生“溢出”的量,它的值在计量器上表示不出来,计量器上只能表示出模的余数.任何有模的计量器,均可化减法为加法运算。</p><p>例如：时种的范围为1~12，那么它的模就等于12，如果我们要计算<span class="math inline">\(9-4\)</span>，即 <span class="math inline">\(9+(-4)\)</span>,就可以将-4替换为它的的补数8来实现（如果两个数绝对值之和等于模，则这两个数互为补数），<span class="math inline">\(9+8=17\)</span>，而超出模的部分机器会自动减去模加以修正，和时钟超出一圈后从原点开始原理相同，因此<span class="math inline">\(17 = 5（mod\12）\)</span>，利用加法实现了减法运算，补码原理相同，补码就是在原码真值基础上加模<span class="math inline">\(2^{n}\)</span>产生（n代表位数）。</p><p>首先设小数 <span class="math inline">\([x]_补 =x_0.x_1x_2x_3…x_n\)</span>，设<span class="math inline">\(x\)</span>为真值，此时模为2<strong>如果x为正数</strong>：则x = <span class="math inline">\(\sum_{i=1}^nx_i2^{-i}\)</span><strong>如果x为负数</strong>：则在这里 <span class="math inline">\([x]_补\)</span>的十进制数值（不是真值，真值是需要考虑符号位的）等于 <span class="math inline">\(x+2\)</span> 而<span class="math inline">\([x]_补\)</span>的真值还可以写成<span class="math inline">\(x_0+\sum_{i=1}^nx_i2^{-i}\)</span> <span class="math display">\[ 1+\sum_{i=1}^nx_i2^{-i} = x+2 \\x = -1 +\sum_{i=1}^nx_i2^{-i} \]</span></p><p>正数时可以写成<span class="math inline">\(-0+\sum_{i=1}^nx_i2^{-i}\)</span>，总结两种情况x的真值可以写成<span class="math inline">\(-x_0+\sum_{i=1}^nx_i2^{-i}\)</span>(注意这只是一个规律的总结，不是严格意义上的证明)</p><p>利用这个规律我们可以计算<span class="math inline">\([x\timesy]_补\)</span>,设 <span class="math inline">\([y]_补 =y_0.y_1y_2y_3…y_n\)</span>，</p><p><strong>当y&gt;0时，</strong><span class="math display">\[[x\timesy]_补 = [x\times \sum_{i=1}^ny_i2^{-i}]_补 \\= [x]_补 \times \sum_{i=1}^ny_i2^{-i} \]</span><strong>当y&lt;0时，</strong> y的真值为 <span class="math inline">\(\sum_{i=1}^ny_i2^{-i} - 1\)</span></p><p><span class="math display">\[[x\times y]_补 = [x\times(\sum_{i=1}^ny_i2^{-i}-1)]_补 \\= [x]_补 \times \sum_{i=1}^ny_i2^{-i}  - [x]_补 \]</span></p><p>同样总结规律可得：</p><p><span class="math display">\[[x\times y]_补   = [x]_补 \times\sum_{i=1}^ny_i2^{-i} - y_0[x]补 \]</span></p><p>这个式子可以展开一下： <span class="math display">\[[x\times y]_补   = [x]_补 \times （y_12^{-1} + y_2{-2}^2+ … +y_n2^{-n}）- y_0[x]补\]</span> 这一步是关键，将各个2的幂展开，再重新归类项 <span class="math display">\[\begin{aligned}&amp;= [x]_补 \times [ - y_0 + y_1(1 - 2^{-1}) + y_2(2^{-1}- 2^{-2})+ …+y_n(2^{-(n-1)} - 2^{-n})] \\&amp;= [x]_补 \times [(y_1 - y_0) + 2^{-1}(y_2-y_1) +  … +2^{-(n-1)}(y_n-y_{n-1})+2^{-n}(y_{n+1}-y_n)]\\&amp;(设y_{n+1}=0)\end{aligned}\]</span>上面的每一项我理解为乘算后每一位的大小，也就可知部分积（乘以<span class="math inline">\(2^{-1}\)</span>相当于右移一位）</p><p><span class="math display">\[ \begin{aligned}z_0 &amp;= 0\\z_1 &amp;= 2^{-1}[z_0 + [x]_补 \times (y_{n+1}-y_n)]\\…\\z_{n+1}&amp; = z_{n-1} + [x]_补 \times(y_{1}-y_0)\end{aligned}\]</span></p><p>因此根据补码两位之差就可以确定是 <span class="math inline">\(+[x]_补\)</span> 、 <span class="math inline">\(-[x]_补\)</span> 还是 <span class="math inline">\(+0\)</span> 了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基础语法</title>
      <link href="/2023/07/14/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/07/14/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown基础语法">markdown基础语法</h1><span id="more"></span><h2 id="一块级元素">一、块级元素</h2><h3 id="标题">1. 标题：</h3><p>标题前打 # 号加空格，标题和world里的标题类似，采用六级标题</p><h1 id="一级">一级</h1><h2 id="二级">二级</h2><h3 id="三级">三级</h3><h4 id="四级">四级</h4><h5 id="五级">五级</h5><h6 id="六级">六级</h6><p class="heading" id="七级没有了">七级、没有了</p><h3 id="引用">2.引用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是一段引用</span><br></pre></td></tr></table></figure><blockquote><p>这是一段引用</p></blockquote><h3 id="有序列表和无序列表">3.有序列表和无序列表</h3><p>有序列表： 1. 第一步 2. 第二步 1. 二级列表（tab键实现） 1. 三级列表3. ……</p><p>无序列表（使用 - 、 + 或 * ） <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 春</span><br><span class="line"><span class="bullet">+</span> 夏</span><br><span class="line"><span class="bullet">*</span> 秋</span><br><span class="line"><span class="bullet">-</span> 冬</span><br></pre></td></tr></table></figure> - 春 - 夏 - 秋 - 冬</p><h3 id="to-do-list">4.to-do list</h3><p>一个负号+空格+方括号+空格，注意方括号前后和里面都要加空格。可以写成<code>[x]</code>表示完成- [x] 学习 - [ ] 吃饭 - [ ] 睡觉</p><h3 id="代码块">5.代码块</h3><p>三个波浪号（~）后加语言名称，如c、python，代码结束再以三个 ~ 结尾。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 6.高亮 内容前后加两个等于号 ==哈哈哈==</p><h3 id="数学函数">7.数学函数</h3><p><span class="math display">\[\frac{\partial f}{\partial x} = 2\sqrt{a}x\]</span></p><h1 id="二markdown快捷键">二、markdown快捷键</h1><ul><li>ctrl+b 加粗</li><li>ctrl+i 变斜体</li><li>ctrl+m 公式起止符</li></ul><p><a href="https://zhuanlan.zhihu.com/p/142988176">为什么写博客都用markdown</a></p><p><img src="/2023/07/14/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/QQ图片20220627104509.gif"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一个blog：hexo建站遇到的一些问题</title>
      <link href="/2023/07/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/07/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="网站搭建">1. 网站搭建</h1><h2 id="博客预览卡片">1.1. 博客预览卡片</h2><p>刚开始写博客整篇内容都在首页上，找了半天才发现原来是少了这行代码</p><figure><img src="/2023/07/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/2023-07-14-22-58-33.png" alt="2023-07-14-22-58-33.png"><figcaption aria-hidden="true">2023-07-14-22-58-33.png</figcaption></figure><p>代码前面的内容会出现在预览卡片上，后面的内容点进去才可以看到</p><h2 id="hexo插入图片无效">1.2. hexo插入图片无效</h2><p>markdown中添加图片后，hexo加载不出来，搜索了一下需要安装hexo-asset-image插件，结果应该是过时了，还是没有成功加载，后来在知乎上一位大佬提供了解决方法。</p><p>https://zhuanlan.zhihu.com/p/280758822 &gt;-修改_config.yml中的post_asset_folder: true &gt;-<code>$ npm install hexo-image-link --save</code> &gt;- 如果npm下载比较慢的话，尝试 cnpm下载 &gt; -<code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code>&gt; - <code>$ cnpm install hexo-image-link --save</code> &gt;-修改md文件中的图片路径</p><p>问题终于解决。</p><h1 id="写博客">2. 写博客</h1><h2 id="vscode直接粘贴图片到对应文件夹下">2.1.vscode直接粘贴图片到对应文件夹下</h2><p>首先安装插件paste image <img src="/2023/07/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/2023-07-14-23-18-33.png" alt="2023-07-14-23-18-33.png"></p><p>如果我们想要设置只在当前工作区生效，就在当前博客文件夹下建立<code>.vscode</code>文件夹，在刚创立的文件夹中创建<code>settings.json</code>文件，然后添加代码，当然也可以在全局设置中修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;pasteImage.path&quot;</span>: <span class="string">&quot;$&#123;currentFileDir&#125;/$&#123;currentFileNameWithoutExt&#125;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pasteImage.basePath&quot;</span>: <span class="string">&quot;$&#123;currentFileDir&#125;/$&#123;currentFileNameWithoutExt&#125;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pasteImage.prefix&quot;</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pasteImage.insertPattern&quot;</span>: <span class="string">&quot;![$&#123;imageFileName&#125;]($&#123;currentFileNameWithoutExt&#125;$&#123;imageFilePath&#125;$&#123;imageSyntaxSuffix&#125;&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们按ctrl+alt+v（注意不是ctrl+v）就可以直接将图片拷贝到对应文件夹中啦。</p><h2 id="hexo渲染代码段不换行">2.2. hexo渲染代码段不换行</h2><p><img src="/2023/07/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/2023-07-15-10-40-24.png" alt="2023-07-15-10-40-24.png"> 待解决</p><h2 id="主题配置">2.3. 主题配置</h2><p><a href="https://blog.csdn.net/qq_53517370/article/details/128911597">particlex主题配置</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs小记</title>
      <link href="/2023/07/14/nodejs/"/>
      <url>/2023/07/14/nodejs/</url>
      
        <content type="html"><![CDATA[<h1 id="node.js">node.js</h1><span id="more"></span><blockquote><p>nodejs是一款应用程序，是一款软件，可以运行javascrip</p></blockquote><p>服务器：保存html、css、javascript</p><p>nodejs：运行在服务器端，处理用户的请求</p><p>作用：</p><ul><li>开发服务器应用</li><li>开发工具类应用：（基于nodejs）webpack vite babel</li><li>桌面端应用：nodejs——electron——vscode、figma、postman</li></ul><p>下载：LTS（long term support ）长期支持</p><p><a href="https://nodejs.cn/download/">下载 | Node.js 中文网(nodejs.cn)</a></p><p>所有版本：<a href="https://registry.npmmirror.com/binary.html?path=node/">CNPMBinaries Mirror (npmmirror.com)</a></p><h2 id="命令提示符">1.命令提示符</h2><p>切换盘符：C: D:</p><p>切换工作目录 cd</p><p>查看目录文件 dir 查看目录下所有文件 dir /s</p><p>结束输出 ctrl+c</p><p>方向键上下键：调出命令历史</p><p>tab键：补全目录文件名称</p><p>注意点：Node.js中不能使用BOM和DOM的API</p><p>可以使用：console和定时器</p><p>顶级对象：global （在浏览器中是window）</p><p>globalThis 指向顶级对象 等同于global</p><h2 id="buffer">2.Buffer</h2><p>是一段固定长度的内存空间，用于处理二进制数据</p><blockquote><ol type="1"><li>大小固定</li><li>性能较好，可以直接操作计算机内存</li><li>每个元素大小为1字节</li></ol></blockquote><p>创建：</p><p>Buffer.alloc(10)</p><p>Buffer.allocUnsafe(10) 创建时不会清除原先的数据，因此速度更快</p><p>Buffer.from() 从数组、字符串创建buffer</p><p>buf.toString() toString(2) 进制转换</p><p>溢出：舍弃高位数据</p><p>中文：一个utf-8的中文占3个字节</p><h2 id="fs模块file-system-文件系统">3.fs模块（file system文件系统）</h2><h3 id="导入fs模块">3.1. 导入fs模块</h3><p>const fs = require(’fs’)</p><p>fs.writeFile</p><h3 id="文件读写">3.2. 文件读写</h3><p>异步工作模式：先顺序执行代码（主线程：解析js代码IO线程：写入文件，写入结束后将回调函数压入到队列中）</p><p>同步写入 fs.writeFileSync(’’,’’test’)</p><p>追加写入 fs.appendFile()</p><p>流式写入 const ws = fs.createWriteStream(文件名)</p><p>ws.write(内容)</p><p>流式读出 const rs = fs.createReadStream()</p><p>rs.on(’data’, chunk ⇒{})</p><p>rs.on(’end’, {回调函数}）</p><h3 id="文件重命名与移动">3.3. 文件重命名与移动</h3><p>fs.rename(旧路径， 新路径， 回调函数）</p><h3 id="文件删除-fs.rm-fs.unlink">3.4. 文件删除 fs.rm fs.unlink</h3><h3 id="文件夹操作">3.5. 文件夹操作</h3><figure><img src="/2023/07/14/nodejs/Untitled.png" alt="文件夹操作"><figcaption aria-hidden="true">文件夹操作</figcaption></figure><h3 id="查看文件状态">3.6. 查看文件状态</h3><p>fs.stat(文件名，{ .isFile() 是否为文件 .isDirectory()是否为文件夹})</p><h3 id="相对路径">3.7. 相对路径</h3><p><strong>是以命令行的工作目录为基准，dirname保存了当前文件所在目录的绝对路径（可以避免工作目录变化导致程序错误）filename(当前文件的绝对路径）</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
